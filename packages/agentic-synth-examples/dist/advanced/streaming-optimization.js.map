{"version":3,"sources":["../../src/advanced/streaming-optimization.ts"],"sourcesContent":["/**\n * Advanced Streaming Optimization Example\n *\n * This example demonstrates:\n * - Multi-model parallel benchmarking\n * - Adaptive learning with weight adjustment\n * - Real-time streaming updates\n * - Quality assessment algorithms\n * - Performance optimization\n * - Automated model selection\n *\n * Use cases:\n * - Finding the best model for your use case\n * - Optimizing data generation pipelines\n * - Benchmarking AI model performance\n * - Cost-performance analysis\n *\n * @example\n * ```typescript\n * import { StreamingOptimization } from '@ruvector/agentic-synth-examples/advanced';\n *\n * const optimizer = new StreamingOptimization();\n * const results = await optimizer.run({\n *   iterations: 5,\n *   schema: mySchema,\n *   models: ['gemini', 'claude', 'kimi']\n * });\n *\n * console.log(`Best model: ${results.optimalModel}`);\n * ```\n */\n\nimport { AgenticSynth } from '@ruvector/agentic-synth';\n\n/**\n * ANSI color codes for terminal output\n */\nconst colors = {\n  reset: '\\x1b[0m',\n  bright: '\\x1b[1m',\n  dim: '\\x1b[2m',\n  green: '\\x1b[32m',\n  blue: '\\x1b[34m',\n  yellow: '\\x1b[33m',\n  cyan: '\\x1b[36m',\n  magenta: '\\x1b[35m',\n  red: '\\x1b[31m'\n} as const;\n\n/**\n * Model configuration interface for streaming optimization\n */\nexport interface StreamingModelConfig {\n  provider: 'gemini' | 'openrouter';\n  model: string;\n  name: string;\n  weight: number;\n  apiKey?: string;\n}\n\n/**\n * Benchmark result interface for streaming optimization\n */\nexport interface StreamingBenchmarkResult {\n  success: boolean;\n  model: string;\n  duration: number;\n  speed: number;\n  quality: StreamingQualityMetrics;\n  recordsGenerated: number;\n  data?: any[];\n  error?: string;\n}\n\n/**\n * Quality metrics interface for streaming optimization\n */\nexport interface StreamingQualityMetrics {\n  overall: number;\n  completeness: number;\n  dataTypes: number;\n  consistency: number;\n  realism: number;\n}\n\n/**\n * Optimization result interface\n */\nexport interface StreamingOptimizationResult {\n  iterations: StreamingBenchmarkResult[][];\n  modelPerformance: Record<string, StreamingPerformanceHistory[]>;\n  optimalModel: string | null;\n  improvementRate: number;\n}\n\n/**\n * Performance history interface for streaming optimization\n */\nexport interface StreamingPerformanceHistory {\n  iteration: number;\n  quality: number;\n  speed: number;\n  duration: number;\n}\n\n/**\n * Advanced Streaming Optimization Engine\n *\n * This class provides multi-model benchmarking, adaptive learning,\n * and automated model selection for optimal performance.\n */\nexport class StreamingOptimization {\n  private models: StreamingModelConfig[];\n  private performanceHistory: any[] = [];\n  private optimizedPrompts: Map<string, any> = new Map();\n  private learningRate: number = 0.1;\n  private bestModel: string | null = null;\n\n  /**\n   * Create a new streaming optimization engine\n   *\n   * @param customModels - Optional custom model configurations\n   */\n  constructor(customModels?: StreamingModelConfig[]) {\n    this.models = customModels || [\n      {\n        provider: 'gemini',\n        model: 'gemini-2.5-flash',\n        name: 'Gemini Flash',\n        weight: 1.0\n      },\n      {\n        provider: 'openrouter',\n        model: 'anthropic/claude-sonnet-4.5',\n        name: 'Claude Sonnet',\n        weight: 0.8\n      },\n      {\n        provider: 'openrouter',\n        model: 'moonshot/moonshot-v1-32k',\n        name: 'Kimi K2',\n        weight: 0.7\n      }\n    ];\n  }\n\n  /**\n   * Display a banner in the console\n   */\n  private banner(text: string): void {\n    const border = '‚ïê'.repeat(text.length + 4);\n    console.log(`${colors.bright}${colors.magenta}\\n‚ïî${border}‚ïó`);\n    console.log(`‚ïë  ${text}  ‚ïë`);\n    console.log(`‚ïö${border}‚ïù${colors.reset}\\n`);\n  }\n\n  /**\n   * Create a progress bar\n   */\n  private progressBar(\n    current: number,\n    total: number,\n    label: string = '',\n    metrics: Record<string, any> = {}\n  ): string {\n    const width = 40;\n    const percentage = (current / total) * 100;\n    const filled = Math.floor((current / total) * width);\n    const empty = width - filled;\n    const bar = '‚ñà'.repeat(filled) + '‚ñë'.repeat(empty);\n    const percent = percentage.toFixed(1).padStart(5);\n\n    let metricsStr = '';\n    if (Object.keys(metrics).length > 0) {\n      metricsStr = ` ${colors.dim}| ${Object.entries(metrics)\n        .map(([k, v]) => `${k}: ${v}`)\n        .join(' | ')}${colors.reset}`;\n    }\n\n    return `${colors.cyan}${label}${colors.reset} [${colors.green}${bar}${colors.reset}] ${percent}%${metricsStr}`;\n  }\n\n  /**\n   * Initialize AI generators for all configured models\n   */\n  async initializeGenerators(apiKeys: Record<string, string>): Promise<Record<string, AgenticSynth>> {\n    console.log(`${colors.yellow}‚ö° Initializing Multi-Model Generators...${colors.reset}`);\n\n    const generators: Record<string, AgenticSynth> = {};\n\n    for (const modelConfig of this.models) {\n      const apiKey = modelConfig.apiKey || apiKeys[modelConfig.provider];\n\n      if (!apiKey) {\n        console.log(`${colors.yellow}‚ö†Ô∏è  Skipping ${modelConfig.name} - No API key${colors.reset}`);\n        continue;\n      }\n\n      try {\n        generators[modelConfig.name] = new AgenticSynth({\n          provider: modelConfig.provider,\n          model: modelConfig.model,\n          apiKey\n        });\n        console.log(`${colors.green}‚úì ${modelConfig.name} initialized${colors.reset}`);\n      } catch (error: any) {\n        console.log(`${colors.red}‚úó ${modelConfig.name} failed: ${error.message}${colors.reset}`);\n      }\n    }\n\n    return generators;\n  }\n\n  /**\n   * Benchmark a single model\n   */\n  async benchmarkModel(\n    generator: AgenticSynth,\n    modelName: string,\n    schema: Record<string, any>,\n    count: number = 3\n  ): Promise<StreamingBenchmarkResult> {\n    const startTime = Date.now();\n\n    try {\n      const result = await generator.generate('structured', {\n        schema,\n        count\n      });\n\n      const duration = (Date.now() - startTime) / 1000;\n      const data = (result as any).data || result;\n\n      // Calculate quality metrics\n      const quality = this.assessQuality(data, schema);\n      const speed = count / duration;\n\n      return {\n        success: true,\n        model: modelName,\n        duration,\n        speed,\n        quality,\n        recordsGenerated: data.length,\n        data\n      };\n    } catch (error: any) {\n      return {\n        success: false,\n        model: modelName,\n        error: error.message,\n        duration: (Date.now() - startTime) / 1000,\n        speed: 0,\n        quality: {\n          overall: 0,\n          completeness: 0,\n          dataTypes: 0,\n          consistency: 0,\n          realism: 0\n        },\n        recordsGenerated: 0\n      };\n    }\n  }\n\n  /**\n   * Assess the quality of generated data\n   */\n  private assessQuality(data: any[], schema: Record<string, any>): StreamingQualityMetrics {\n    const checks = {\n      completeness: 0,\n      dataTypes: 0,\n      consistency: 0,\n      realism: 0\n    };\n\n    const schemaKeys = Object.keys(schema);\n\n    // Check completeness (all fields present)\n    data.forEach(record => {\n      const recordKeys = Object.keys(record);\n      const hasAllFields = schemaKeys.every(key => recordKeys.includes(key));\n      checks.completeness += hasAllFields ? 1 : 0;\n    });\n    checks.completeness /= data.length;\n\n    // Check data types match\n    data.forEach(record => {\n      let typeMatches = 0;\n      schemaKeys.forEach(key => {\n        const expectedType = schema[key].type;\n        const actualType = typeof record[key];\n        if (\n          (expectedType === 'number' && actualType === 'number') ||\n          (expectedType === 'string' && actualType === 'string') ||\n          (expectedType === 'boolean' && actualType === 'boolean')\n        ) {\n          typeMatches++;\n        }\n      });\n      checks.dataTypes += typeMatches / schemaKeys.length;\n    });\n    checks.dataTypes /= data.length;\n\n    // Consistency and realism (simplified for this example)\n    checks.consistency = 0.85;\n    checks.realism = 0.90;\n\n    const overall = (\n      checks.completeness * 0.3 +\n      checks.dataTypes * 0.3 +\n      checks.consistency * 0.2 +\n      checks.realism * 0.2\n    );\n\n    return {\n      overall,\n      ...checks\n    };\n  }\n\n  /**\n   * Update model weights based on performance (reinforcement learning)\n   */\n  private updateModelWeights(bestModel: string, allResults: StreamingBenchmarkResult[]): void {\n    const bestScore = allResults.find(r => r.model === bestModel)?.quality.overall || 0;\n\n    for (const modelConfig of this.models) {\n      const result = allResults.find(r => r.model === modelConfig.name);\n      if (!result) continue;\n\n      const performanceRatio = result.quality.overall / bestScore;\n      const adjustment = (performanceRatio - 1) * this.learningRate;\n      modelConfig.weight = Math.max(0.1, Math.min(1.0, modelConfig.weight + adjustment));\n    }\n\n    // Decay learning rate over time\n    this.learningRate *= 0.95;\n  }\n\n  /**\n   * Run optimization with adaptive learning\n   */\n  async optimizeWithLearning(\n    generators: Record<string, AgenticSynth>,\n    schema: Record<string, any>,\n    iterations: number = 5\n  ): Promise<StreamingOptimizationResult> {\n    this.banner('üß† ADAPTIVE LEARNING OPTIMIZATION');\n\n    const results: StreamingOptimizationResult = {\n      iterations: [],\n      modelPerformance: {},\n      optimalModel: null,\n      improvementRate: 0\n    };\n\n    for (let i = 1; i <= iterations; i++) {\n      console.log(`\\n${this.progressBar(i - 1, iterations, `Iteration ${i}/${iterations}`)}`);\n      console.log(`${colors.yellow}üî¨ Testing all models in parallel...${colors.reset}\\n`);\n\n      // Test all models in parallel\n      const modelTests = Object.entries(generators).map(([name, gen]) =>\n        this.benchmarkModel(gen, name, schema)\n      );\n\n      const benchmarks = await Promise.all(modelTests);\n\n      // Process and display results\n      const iterationResults: StreamingBenchmarkResult[] = [];\n\n      for (const benchmark of benchmarks) {\n        if (!benchmark.success) {\n          console.log(`${colors.red}‚úó ${benchmark.model}: Failed - ${benchmark.error}${colors.reset}`);\n          continue;\n        }\n\n        iterationResults.push(benchmark);\n\n        console.log(`${colors.green}‚úì ${benchmark.model}${colors.reset}`);\n        console.log(`  Time: ${colors.cyan}${benchmark.duration.toFixed(2)}s${colors.reset} | ` +\n                    `Speed: ${colors.cyan}${benchmark.speed.toFixed(2)} rec/s${colors.reset} | ` +\n                    `Quality: ${colors.cyan}${(benchmark.quality.overall * 100).toFixed(1)}%${colors.reset}`);\n\n        // Track performance\n        if (!results.modelPerformance[benchmark.model]) {\n          results.modelPerformance[benchmark.model] = [];\n        }\n        results.modelPerformance[benchmark.model].push({\n          iteration: i,\n          quality: benchmark.quality.overall,\n          speed: benchmark.speed,\n          duration: benchmark.duration\n        });\n      }\n\n      // Find best model this iteration\n      const successfulResults = iterationResults.filter(r => r.success);\n      if (successfulResults.length > 0) {\n        const bestThisIteration = successfulResults.reduce((best, current) =>\n          current.quality.overall > best.quality.overall ? current : best\n        );\n\n        console.log(`\\n${colors.bright}${colors.green}üèÜ Best this iteration: ${bestThisIteration.model}${colors.reset}\\n`);\n\n        // Update weights\n        this.updateModelWeights(bestThisIteration.model, successfulResults);\n      }\n\n      results.iterations.push(iterationResults);\n\n      // Small delay for streaming effect\n      if (i < iterations) {\n        await new Promise(resolve => setTimeout(resolve, 300));\n      }\n    }\n\n    // Determine optimal model\n    const modelScores: Record<string, number> = {};\n    for (const [model, history] of Object.entries(results.modelPerformance)) {\n      const avgQuality = history.reduce((sum, r) => sum + r.quality, 0) / history.length;\n      const avgSpeed = history.reduce((sum, r) => sum + r.speed, 0) / history.length;\n      modelScores[model] = avgQuality * 0.7 + (avgSpeed / 10) * 0.3;\n    }\n\n    let optimalModel: string | null = null;\n    let bestScore = 0;\n\n    for (const [model, score] of Object.entries(modelScores)) {\n      if (score > bestScore) {\n        bestScore = score;\n        optimalModel = model;\n      }\n    }\n\n    results.optimalModel = optimalModel;\n    this.bestModel = optimalModel;\n\n    return results;\n  }\n\n  /**\n   * Run the complete optimization pipeline\n   */\n  async run(options: {\n    schema: Record<string, any>;\n    iterations?: number;\n    apiKeys?: Record<string, string>;\n  }): Promise<StreamingOptimizationResult> {\n    this.banner('üöÄ ADVANCED STREAMING OPTIMIZATION ENGINE');\n\n    const apiKeys = options.apiKeys || {\n      gemini: process.env.GEMINI_API_KEY || process.env.GOOGLE_GEMINI_API_KEY || '',\n      openrouter: process.env.OPENROUTER_API_KEY || ''\n    };\n\n    const generators = await this.initializeGenerators(apiKeys);\n\n    if (Object.keys(generators).length === 0) {\n      throw new Error('No generators initialized. Check API keys.');\n    }\n\n    const results = await this.optimizeWithLearning(\n      generators,\n      options.schema,\n      options.iterations || 5\n    );\n\n    this.displayFinalAnalysis(results);\n\n    return results;\n  }\n\n  /**\n   * Display final analysis\n   */\n  private displayFinalAnalysis(results: StreamingOptimizationResult): void {\n    this.banner('üìä OPTIMIZATION COMPLETE - FINAL ANALYSIS');\n\n    console.log(`${colors.cyan}üéØ Optimal Model:${colors.reset} ${colors.bright}${colors.green}${results.optimalModel}${colors.reset}\\n`);\n    console.log(`${colors.cyan}üìà Model Performance Summary:${colors.reset}\\n`);\n\n    for (const [model, history] of Object.entries(results.modelPerformance)) {\n      const avgQuality = history.reduce((sum, r) => sum + r.quality, 0) / history.length;\n      const avgSpeed = history.reduce((sum, r) => sum + r.speed, 0) / history.length;\n\n      const isOptimal = model === results.optimalModel;\n      const prefix = isOptimal ? `${colors.green}‚òÖ` : ` `;\n\n      console.log(`${prefix} ${colors.bright}${model}${colors.reset}`);\n      console.log(`  Quality:  ${colors.cyan}${(avgQuality * 100).toFixed(1)}%${colors.reset}`);\n      console.log(`  Speed:    ${colors.cyan}${avgSpeed.toFixed(2)} rec/s${colors.reset}\\n`);\n    }\n\n    console.log(`${colors.cyan}üí° Recommendations:${colors.reset}`);\n    console.log(`  1. Use ${colors.bright}${results.optimalModel}${colors.reset} for production workloads`);\n    console.log(`  2. Quality-focused tasks: Use highest quality model`);\n    console.log(`  3. Speed-focused tasks: Use fastest model`);\n    console.log(`  4. Cost-optimized: Use Gemini Flash for best value\\n`);\n  }\n}\n\n/**\n * Example usage\n */\nexport async function runStreamingOptimizationExample() {\n  const optimizer = new StreamingOptimization();\n\n  // Stock market data schema\n  const schema = {\n    timestamp: { type: 'string', description: 'ISO 8601 timestamp' },\n    symbol: { type: 'string', description: 'Stock ticker (AAPL, GOOGL, etc.)' },\n    open: { type: 'number', description: 'Opening price in USD' },\n    high: { type: 'number', description: 'Highest price in USD' },\n    low: { type: 'number', description: 'Lowest price in USD' },\n    close: { type: 'number', description: 'Closing price in USD' },\n    volume: { type: 'number', description: 'Trading volume' },\n    sentiment: { type: 'string', description: 'Market sentiment: bullish, bearish, neutral' }\n  };\n\n  const results = await optimizer.run({\n    schema,\n    iterations: 5\n  });\n\n  console.log(`\\n‚ú® Optimal model for your use case: ${results.optimalModel}`);\n\n  return results;\n}\n"],"mappings":"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","names":[]}